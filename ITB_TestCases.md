# APIトラベル - 統合テスト（ITB）テストケース

## 1. はじめに

このドキュメントでは、APIトラベルアプリケーションの統合テスト（ITB）テストケースを定義しています。これらのテストケースは、エンドツーエンドの機能が期待どおりに動作することを確認するように設計されています。

## 2. 前提条件

- テスト環境が適切に設定されている（データベース、外部サービスなど）
- テストデータが利用可能である
- APIキーが設定されている

## 3. テスト環境

- **URL**: http://localhost:8080
- **API Version**: v1
- **API Key**: FX001-FREE
- **データベース**: PostgreSQL (localhost:5432/travels)

## 4. テストシナリオ

### シナリオ 1: 基本的なユーザー、口座、旅行フロー

#### テストケース 1.1: 新規ユーザー登録と認証

**目的**: ユーザー登録から認証までの基本フローをテストする

**ステップ**:
1. 新規ユーザーを作成する (`POST /api-travels/v1/users`)
   ```json
   {
     "name": "Test User",
     "email": "test@example.com",
     "password": "password123",
     "role": "ROLE_USER"
   }
   ```

2. 作成したユーザーの認証情報でJWTトークンを取得する (`POST /api-travels/v1/auth`)
   ```json
   {
     "email": "test@example.com",
     "password": "password123"
   }
   ```

**期待される結果**:
- ユーザーが正常に作成される（201 Created）
- JWTトークンが正常に発行される（200 OK）
- レスポンスには有効なトークンが含まれる

**検証ポイント**:
- ユーザー作成レスポンスのステータスコードとボディ
- トークン取得レスポンスのステータスコードとボディ
- トークンの有効性

---

#### テストケース 1.2: 口座の作成

**目的**: ユーザー認証後に口座を作成する機能をテストする

**前提条件**:
- テストケース1.1が成功している
- 有効なJWTトークンが利用可能

**ステップ**:
1. 新規口座を作成する (`POST /api-travels/v1/accounts`)
   ```json
   {
     "accountNumber": "ACC123456",
     "accountType": "BASIC"
   }
   ```
   ヘッダー:
   ```
   Authorization: Bearer {JWT_TOKEN}
   X-api-key: FX001-FREE
   ```

**期待される結果**:
- 口座が正常に作成される（201 Created）
- レスポンスには口座の詳細とHATEOASリンクが含まれる

**検証ポイント**:
- レスポンスのステータスコード
- 口座番号と種類が正しいか
- HATEOASリンクが正しく含まれているか

---

#### テストケース 1.3: ユーザーと口座の関連付け

**目的**: ユーザーと口座を関連付ける機能をテストする

**前提条件**:
- テストケース1.1と1.2が成功している
- 有効なJWTトークンが利用可能
- ユーザーIDと口座IDが利用可能

**ステップ**:
1. ユーザーと口座を関連付ける (`POST /api-travels/v1/users/accounts`)
   ```json
   {
     "userId": {USER_ID},
     "accountId": {ACCOUNT_ID}
   }
   ```
   ヘッダー:
   ```
   Authorization: Bearer {JWT_TOKEN}
   X-api-key: FX001-FREE
   ```

**期待される結果**:
- ユーザーと口座が正常に関連付けられる（201 Created）
- レスポンスには関連付けの詳細が含まれる

**検証ポイント**:
- レスポンスのステータスコード
- ユーザーIDと口座IDが正しいか
- HATEOASリンクが正しく含まれているか

---

#### テストケース 1.4: 旅行の作成

**目的**: 旅行を作成する機能をテストする

**前提条件**:
- テストケース1.1、1.2、1.3が成功している
- 有効なJWTトークンが利用可能
- 口座IDが利用可能

**ステップ**:
1. 新規旅行を作成する (`POST /api-travels/v1/travels`)
   ```json
   {
     "orderNumber": "ORD123456",
     "startDate": "2025-03-01T10:00:00.000Z",
     "endDate": "2025-03-08T18:00:00.000Z",
     "amount": 1500.00,
     "type": "RETURN",
     "accountId": {ACCOUNT_ID}
   }
   ```
   ヘッダー:
   ```
   Authorization: Bearer {JWT_TOKEN}
   X-api-key: FX001-FREE
   ```

**期待される結果**:
- 旅行が正常に作成される（201 Created）
- レスポンスには旅行の詳細とHATEOASリンクが含まれる

**検証ポイント**:
- レスポンスのステータスコード
- 注文番号、日付、金額、種類などが正しいか
- HATEOASリンクが正しく含まれているか

---

#### テストケース 1.5: 特定期間の旅行の検索

**目的**: 特定期間の旅行を検索する機能をテストする

**前提条件**:
- テストケース1.4が成功している
- 有効なJWTトークンが利用可能

**ステップ**:
1. 特定期間の旅行を検索する (`GET /api-travels/v1/travels?startDate=2025-03-01&endDate=2025-03-31`)
   ヘッダー:
   ```
   Authorization: Bearer {JWT_TOKEN}
   X-api-key: FX001-FREE
   ```

**期待される結果**:
- 検索結果が正常に取得される（200 OK）
- レスポンスには期間内の旅行のリストが含まれる

**検証ポイント**:
- レスポンスのステータスコード
- 返される旅行が指定期間内か
- ページネーション情報が正しいか
- 各旅行のHATEOASリンクが正しく含まれているか

---

### シナリオ 2: エラーケースと例外処理

#### テストケース 2.1: 無効なユーザー認証

**目的**: 無効な認証情報でのエラー処理をテストする

**ステップ**:
1. 無効なメールアドレスで認証を試みる (`POST /api-travels/v1/auth`)
   ```json
   {
     "email": "nonexistent@example.com",
     "password": "password123"
   }
   ```

2. 無効なパスワードで認証を試みる (`POST /api-travels/v1/auth`)
   ```json
   {
     "email": "test@example.com",
     "password": "wrongpassword"
   }
   ```

**期待される結果**:
- 両方のケースで認証失敗（401 Unauthorized）
- エラーメッセージが返される

**検証ポイント**:
- レスポンスのステータスコード
- エラーメッセージの内容

---

#### テストケース 2.2: 無効な旅行データ

**目的**: 無効な旅行データでのエラー処理をテストする

**前提条件**:
- テストケース1.1と1.2が成功している
- 有効なJWTトークンが利用可能

**ステップ**:
1. 開始日が終了日より後の旅行を作成しようとする (`POST /api-travels/v1/travels`)
   ```json
   {
     "orderNumber": "ORD123456",
     "startDate": "2025-03-10T10:00:00.000Z",
     "endDate": "2025-03-01T18:00:00.000Z",
     "amount": 1500.00,
     "type": "RETURN",
     "accountId": {ACCOUNT_ID}
   }
   ```

2. 必須フィールドが欠けている旅行を作成しようとする (`POST /api-travels/v1/travels`)
   ```json
   {
     "startDate": "2025-03-01T10:00:00.000Z",
     "endDate": "2025-03-08T18:00:00.000Z",
     "amount": 1500.00,
     "type": "RETURN",
     "accountId": {ACCOUNT_ID}
   }
   ```

**期待される結果**:
- 両方のケースでバリデーションエラー（422 Unprocessable Entity または 400 Bad Request）
- エラーメッセージが返される

**検証ポイント**:
- レスポンスのステータスコード
- エラーメッセージの内容

---

#### テストケース 2.3: 存在しない旅行の検索

**目的**: 存在しない旅行を検索した場合のエラー処理をテストする

**前提条件**:
- 有効なJWTトークンが利用可能

**ステップ**:
1. 存在しない注文番号で旅行を検索する (`GET /api-travels/v1/travels/byOrderNumber/NONEXISTENT`)
   ヘッダー:
   ```
   Authorization: Bearer {JWT_TOKEN}
   X-api-key: FX001-FREE
   ```

2. 存在しないIDで旅行を検索する (`GET /api-travels/v1/travels/9999`)
   ヘッダー:
   ```
   Authorization: Bearer {JWT_TOKEN}
   X-api-key: FX001-FREE
   ```

**期待される結果**:
- 両方のケースで「見つかりません」エラー（404 Not Found）
- エラーメッセージが返される

**検証ポイント**:
- レスポンスのステータスコード
- エラーメッセージの内容

---

### シナリオ 3: 旅行の更新と削除

#### テストケース 3.1: 旅行の更新

**目的**: 旅行情報を更新する機能をテストする

**前提条件**:
- テストケース1.4が成功している
- 有効なJWTトークンが利用可能
- 既存の旅行IDが利用可能

**ステップ**:
1. 旅行情報を更新する (`PUT /api-travels/v1/travels/{TRAVEL_ID}`)
   ```json
   {
     "id": {TRAVEL_ID},
     "orderNumber": "ORD123456",
     "startDate": "2025-03-01T10:00:00.000Z",
     "endDate": "2025-03-10T18:00:00.000Z",
     "amount": 2000.00,
     "type": "RETURN",
     "accountId": {ACCOUNT_ID}
   }
   ```
   ヘッダー:
   ```
   Authorization: Bearer {JWT_TOKEN}
   X-api-key: FX001-FREE
   ```

**期待される結果**:
- 旅行が正常に更新される（200 OK）
- レスポンスには更新された旅行の詳細とHATEOASリンクが含まれる

**検証ポイント**:
- レスポンスのステータスコード
- 日付と金額が正しく更新されているか
- HATEOASリンクが正しく含まれているか

---

#### テストケース 3.2: 旅行の削除

**目的**: 旅行を削除する機能をテストする

**前提条件**:
- テストケース1.4が成功している
- 有効なJWTトークンが利用可能
- 既存の旅行IDが利用可能

**ステップ**:
1. 旅行を削除する (`DELETE /api-travels/v1/travels/{TRAVEL_ID}`)
   ヘッダー:
   ```
   Authorization: Bearer {JWT_TOKEN}
   X-api-key: FX001-FREE
   ```

2. 削除した旅行を再度取得しようとする (`GET /api-travels/v1/travels/{TRAVEL_ID}`)
   ヘッダー:
   ```
   Authorization: Bearer {JWT_TOKEN}
   X-api-key: FX001-FREE
   ```

**期待される結果**:
- 削除操作が成功する（204 No Content）
- 削除した旅行の取得で「見つかりません」エラー（404 Not Found）

**検証ポイント**:
- 削除操作のレスポンスのステータスコード
- 削除確認メッセージの内容
- 削除後の取得操作のレスポンスのステータスコード

---

### シナリオ 4: セキュリティとアクセス制御

#### テストケース 4.1: トークンなしでのアクセス

**目的**: 認証が必要なエンドポイントにトークンなしでアクセスした場合の動作をテストする

**ステップ**:
1. トークンなしで旅行を検索する (`GET /api-travels/v1/travels?startDate=2025-03-01&endDate=2025-03-31`)
   ヘッダー:
   ```
   X-api-key: FX001-FREE
   ```

**期待される結果**:
- 認証エラー（401 Unauthorized）

**検証ポイント**:
- レスポンスのステータスコード
- エラーメッセージの内容

---

#### テストケース 4.2: 有効期限切れトークンでのアクセス

**目的**: 有効期限切れのトークンでのエラー処理をテストする

**ステップ**:
1. 有効期限切れのJWTトークンで旅行を検索する (`GET /api-travels/v1/travels?startDate=2025-03-01&endDate=2025-03-31`)
   ヘッダー:
   ```
   Authorization: Bearer {EXPIRED_JWT_TOKEN}
   X-api-key: FX001-FREE
   ```

**期待される結果**:
- 認証エラー（401 Unauthorized）
- トークン有効期限切れのエラーメッセージ

**検証ポイント**:
- レスポンスのステータスコード
- エラーメッセージの内容

---

#### テストケース 4.3: 無効なAPIキーでのアクセス

**目的**: 無効なAPIキーでのエラー処理をテストする

**前提条件**:
- 有効なJWTトークンが利用可能

**ステップ**:
1. 無効なAPIキーで旅行を検索する (`GET /api-travels/v1/travels?startDate=2025-03-01&endDate=2025-03-31`)
   ヘッダー:
   ```
   Authorization: Bearer {JWT_TOKEN}
   X-api-key: INVALID-KEY
   ```

**期待される結果**:
- アクセス拒否エラー（403 Forbidden）

**検証ポイント**:
- レスポンスのステータスコード
- エラーメッセージの内容

---

### シナリオ 5: 統計機能のテスト

#### テストケース 5.1: 旅行統計の取得

**目的**: 旅行統計を取得する機能をテストする

**前提条件**:
- テストケース1.4が成功している
- 有効なJWTトークンが利用可能

**ステップ**:
1. 旅行統計を取得する (`GET /api-travels/v1/statistics`)
   ヘッダー:
   ```
   Authorization: Bearer {JWT_TOKEN}
   X-api-key: FX001-FREE
   ```

**期待される結果**:
- 統計情報が正常に取得される（200 OK）
- レスポンスには合計、平均、最大、最小、カウントなどの統計情報が含まれる

**検証ポイント**:
- レスポンスのステータスコード
- 統計情報の正確性
- HATEOASリンクが正しく含まれているか

---

### シナリオ 6: パフォーマンステスト

#### テストケース 6.1: 大量リクエスト時の応答性

**目的**: システムが大量リクエストに対しても適切に応答することを確認する

**前提条件**:
- 有効なJWTトークンが利用可能

**ステップ**:
1. 10秒間で100回の旅行検索リクエストを送信する (`GET /api-travels/v1/travels?startDate=2025-03-01&endDate=2025-03-31`)
   ヘッダー:
   ```
   Authorization: Bearer {JWT_TOKEN}
   X-api-key: FX001-FREE
   ```

**期待される結果**:
- すべてのリクエストが正常に処理される
- 平均応答時間が500ms未満

**検証ポイント**:
- リクエストの成功率
- 応答時間
- エラーレスポンスの有無

---

## 5. テスト実行の注意事項

1. テストは順番に実行する必要があります（特にシナリオ1内のテストケース）
2. 各テストの前に適切なセットアップと後に適切なクリーンアップを行うこと
3. テスト環境のデータベースは各テスト実行前にリセットすることを推奨
4. すべてのテストで適切なヘッダー情報を設定すること
5. テスト結果はログファイルとして保存し、後で分析できるようにすること
